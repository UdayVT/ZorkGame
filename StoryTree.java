/**
 * a fully-documented class named StoryTree, which represents the primary data structure for the Zork game. 
 * This class should be a 10-ary (10-child) tree of StoryTreeNodes, which are structured as a continuous chain of
 *  decisions the user may make to reach the end of the game (any leaf node).
 * @author 
 * 		Uday Turakhia, SBU ID #: 115102637
 * <dt><b>Assignment:</b><dd>
 *    Homework #5 for CSE 214, Spring 2023
 * 		Recitation #: R03
 * <dt><b>Date:</b><dd>
 *    April 5th, 2023
 */
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.zip.DataFormatException;
import java.util.Scanner;

public class StoryTree 
{
    private StoryTreeNode root;//The root of the tree
    private StoryTreeNode cursor;//the cursor of the tree
    private GameState state = GameState.GAME_NOT_OVER;//A gameState enum which defines the state of the game

    /**
     * Default Constructor
     */
    public StoryTree()
    {
       root = new StoryTreeNode("root", "root", "Hello, and welcome to Zork!");
       cursor = root;
       state = GameState.GAME_NOT_OVER;
    }

    /**
     * Reads in a text file describing a StoryTree.
     * @param filename
     *      Name of the file to read from.
     * @return
     *      A new StoryTree generated by the passed in text file is returned.
     * @throws IllegalArgumentException
     *      filename is empty or null.
     * @throws DataFormatException
     *      The file contained data inconsistent with the expected data format
     * @throws IOException
     *      if there is some problem with reading file
     * @throws FileNotFoundException
     *      if the file is not found
     * @throws FullTreeException
     *      if the tree becomes full while making tree.
     */
    public static StoryTree readTree(String filename) throws IllegalArgumentException, DataFormatException, IOException, FileNotFoundException, FullTreeException
    {
        if(filename.length() == 0 || filename == null)
            throw new IllegalArgumentException("Invalid Input");

        StoryTree tree = new StoryTree();
        
        File text = new File(filename);
        if(!text.createNewFile())
        {
            try (Scanner fileIn = new Scanner(text)) {
                while(fileIn.hasNextLine()) 
                {
                    String line =  fileIn.nextLine();
                    
                    if(line.trim() == "")
                        continue;

                    String[] node = line.split("\\|");
                    if(node.length != 3)
                        throw new DataFormatException("Data format error");

                    StoryTreeNode currentNode = tree.getRoot();
                    for(int i = 0; i<node[0].length();i++)
                    {
                        if(!Character.isDigit(node[0].charAt(i)))
                            continue;

                        String temp = "";
                        char pos = node[0].charAt(i);
                        temp += pos;

                        
                        if(Integer.parseInt(temp) == 0)
                        {
                            temp = 1+temp;
                        }
                                                
                        if(currentNode.getChildRef(Integer.parseInt(temp)-1) == null)
                        {
                            currentNode.addChild(node[1].trim(), node[2].trim());
                        }
                        else
                        {
                            currentNode = currentNode.getChildRef(Integer.parseInt(temp)-1);   
                        }
                    }
                }
                fileIn.close();
            }   
            return tree;
        }
        else
        {
            throw new FileNotFoundException();
        }
    }

    /**
     * Saves a StoryTree to the indicated file using the specified data format (same as input).
     * @param filename
     *      Name of the file to save to.
     * @param tree
     *      A reference to the tree to save to the indicated file.
     * @throws FileNotFoundException
     *      If the file is not found
     */
    public static void saveTree(String filename, StoryTree tree) throws FileNotFoundException
    {
        PrintWriter fileOut = new PrintWriter(filename);
        if(tree.getRoot().getNumChild() != 0)
            fileOut.write(tree.getRoot().getChildRef(0).printToString());
        fileOut.close();
    }

    /**
     * Getter of Root
     * @return
     *      the root
     */
    public StoryTreeNode getRoot() 
    {
        return root;
    }

    /**
     * Getter of gameState
     * @return
     *      gamestate
     */
    public GameState getGameState() 
    {
        return state;
    }

    /**
     * Getter of cursor's position
     * @return
     *      cursor's position
     */
    public String getCursorPosition() 
    {
        return cursor.getPosition();
    }

    /**
     * Getter of cursor's message
     * @return
     *      cursor's message
     */
    public String getCursorMessage()
    {
        return cursor.getMessage();
    }

    /**
     * Getter of cursor's options
     * @return
     *      cursor's options
     */
    public String[][] getCursorOptions()
    {
        return cursor.getOptions();
    }

    /**
     * Setter of cursor's message
     * @param message
     *      new message
     */
    public void setCursorMessage(String message)
    {
        cursor.setMessage(message);
    }

    /**
     * Setter of cursor's option
     * @param option
     *      new option
     */
    public void setCursorOption(String option)
    {
        cursor.setOption(option);
    }

    /**
     * Resets the cursor to the first child of root
     */
    public void resetCursor()
    {
        cursor = root.getChildRef(0);
    }

    /**
     * Select a child from the current node
     * @param position
     *      The position String of the child to node to select.
     * @throws IllegalArgumentException
     *      position is empty or null.  
     * @throws NodeNotPresentException
     *      Node with indicated position variable was not found.
     */
    public void selectChild(String position) throws IllegalArgumentException, NodeNotPresentException
    {
        if(position.length() == 0 || position == null)
            throw new IllegalArgumentException("Invalid Position");

        int pos = Integer.parseInt(position);
        if(pos > cursor.getNumChild() || pos < 1)
        {
            throw new NodeNotPresentException("Could not find the node");
        } 

        cursor = cursor.getChildRef(pos-1);

        if(cursor.isWinningNode())
            state = GameState.GAME_OVER_WIN;
        else if(cursor.isLossingNode())
            state = GameState.GAME_OVER_LOSE;
        else
            state = GameState.GAME_NOT_OVER;
    }

    /**
     * Adds a new child under the current cursor, with given option and message
     * @param option
     *      The new String to set as the option of the new child.
     * @param message
     *      The new String to set as the message of the new child.
     * @throws IllegalArgumentException
     *      Either String is empty or null.
     * @throws FullTreeException
     *      All 10 child spots are already full.
     */
    public void addChild(String option, String message) throws IllegalArgumentException,FullTreeException
    {
        if(option.trim().length() == 0 || option == null || message.trim().length() == 0 || message == null) 
            throw new IllegalArgumentException();

        cursor.addChild(option, message);
    }

    /**
     * Removes an immediate child under the current cursor. 
     * This method implicitly removes the entire sub-tree for which the indicated child is root
     * @param position
     *      String indicating the position of the child to be removed.
     * @return
     *      A reference to the child removed (along with it's attached sub-tree).
     * @throws IllegalArgumentException
     *      if position is empty or null
     * @throws NodeNotPresentException
     *      Node with indicated position variable was not found.
     */
    public StoryTreeNode removeChild(String position) throws IllegalArgumentException,NodeNotPresentException
    {
        if(position.trim().length() == 0 || position == null)
            throw new IllegalArgumentException("Invalid Position");

        int pos = Integer.parseInt(position);

        if(pos > cursor.getNumChild() || pos < 1)
            throw new NodeNotPresentException("Could not find the node");

        return cursor.removeChild(pos-1);
    }

    /**
     * Setter of state
     * @param state
     *      new gameState
     */
    public void setState(GameState state) 
    {
        this.state = state;
    }

    /**
     * Getter of cursor's option
     * @return
     *      cursor's option
     */
    public String getCursorOption()
    {
        return cursor.getOption();
    }

    /**
     * ToString of cursor during play
     * @return
     *      A neatly formatted string
     */
    public String cursorPlayToString()
    {
        return cursor.playToString();
    }

    /**
     * ToString of cursor during editing
     * @return
     *      A neatly formatted string
     */
    public String cursorEditToString()
    {
        return cursor.editToString();
    }

    /**
     * The win probability from the cursor
     * @return
     *      A double of win probability
     */
    public double winProbability()
    {
        return cursor.winProbability();
    }

    /**
     * Setter of cursor
     * @param r
     *      new Node
     */
    public void SetCursor(StoryTreeNode r)
    {
        cursor = r;
    }

    /**
     * Goes back to parent
     * @throws NodeNotPresentException
     *      if no parent exisits. 
     */
    public void goBackToParent() throws NodeNotPresentException
    {
        if(cursor == root || cursor == root.getChildRef(0) || cursor.getParentRef() == null)
            throw new NodeNotPresentException("Cannot go back to parent");

        cursor = cursor.getParentRef();
    }
}
